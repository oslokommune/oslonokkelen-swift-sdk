// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messages.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Messages sent between OslonÃ¸kkelen and adapters.
///
/// Important concepts:
///  - All messages sent from the server to the adapter WILL be wrapped in the MessageFromServer type.
///  - All messages sent from the adapter to the server WILL be wrapped in the MessageFromAdapter type.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// All messages sent from the server will be wrapped in this message. 
struct ONMessageFromServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Uniquely identifies this message
  var messageID: String {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  /// Indicates that this message is a direct response to another specific message. Optional.
  /// No message should ever result in more then one reply.
  var replyToMessageID: String {
    get {return _storage._replyToMessageID}
    set {_uniqueStorage()._replyToMessageID = newValue}
  }

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Used to acknowledge receipt of a message
  var receipt: ONReceiptMessage {
    get {
      if case .receipt(let v)? = _storage._message {return v}
      return ONReceiptMessage()
    }
    set {_uniqueStorage()._message = .receipt(newValue)}
  }

  /// Ping, please respond with a PongMessage
  var ping: ONPingMessage {
    get {
      if case .ping(let v)? = _storage._message {return v}
      return ONPingMessage()
    }
    set {_uniqueStorage()._message = .ping(newValue)}
  }

  /// Please execute this action
  var actionRequest: ONActionRequestMessage {
    get {
      if case .actionRequest(let v)? = _storage._message {return v}
      return ONActionRequestMessage()
    }
    set {_uniqueStorage()._message = .actionRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    /// Used to acknowledge receipt of a message
    case receipt(ONReceiptMessage)
    /// Ping, please respond with a PongMessage
    case ping(ONPingMessage)
    /// Please execute this action
    case actionRequest(ONActionRequestMessage)

  #if !swift(>=4.1)
    static func ==(lhs: ONMessageFromServer.OneOf_Message, rhs: ONMessageFromServer.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.receipt(let l), .receipt(let r)): return l == r
      case (.ping(let l), .ping(let r)): return l == r
      case (.actionRequest(let l), .actionRequest(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Messages that can be initiated by the client 
struct ONMessageFromAdapter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Uniquely identifies this message
  var messageID: String {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  /// Indicates that this message is a direct response to another specific message. Optional.
  /// No message should ever result in more then one reply.
  var replyToMessageID: String {
    get {return _storage._replyToMessageID}
    set {_uniqueStorage()._replyToMessageID = newValue}
  }

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Used to acknowledge receipt of a message
  var receipt: ONReceiptMessage {
    get {
      if case .receipt(let v)? = _storage._message {return v}
      return ONReceiptMessage()
    }
    set {_uniqueStorage()._message = .receipt(newValue)}
  }

  /// A detailed list of all the things attached to this adapter and the actions they support.
  var manifest: ONManifestMessage {
    get {
      if case .manifest(let v)? = _storage._message {return v}
      return ONManifestMessage()
    }
    set {_uniqueStorage()._message = .manifest(newValue)}
  }

  /// Things can have state / properties like battery level, temperature etc. Use this message
  /// to communicate changes to the backend .
  var propertyUpdate: ONPropertyUpdateMessage {
    get {
      if case .propertyUpdate(let v)? = _storage._message {return v}
      return ONPropertyUpdateMessage()
    }
    set {_uniqueStorage()._message = .propertyUpdate(newValue)}
  }

  /// Response to a ping.
  var pong: ONPongMessage {
    get {
      if case .pong(let v)? = _storage._message {return v}
      return ONPongMessage()
    }
    set {_uniqueStorage()._message = .pong(newValue)}
  }

  /// Each adapter should report the health state of all actions.
  /// The backend will not attempt to execute actions reported broken.
  var healthUpdate: ONHealthMessage {
    get {
      if case .healthUpdate(let v)? = _storage._message {return v}
      return ONHealthMessage()
    }
    set {_uniqueStorage()._message = .healthUpdate(newValue)}
  }

  /// The result of an ActionRequestMessage.
  var actionResponse: ONActionResponseMessage {
    get {
      if case .actionResponse(let v)? = _storage._message {return v}
      return ONActionResponseMessage()
    }
    set {_uniqueStorage()._message = .actionResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    /// Used to acknowledge receipt of a message
    case receipt(ONReceiptMessage)
    /// A detailed list of all the things attached to this adapter and the actions they support.
    case manifest(ONManifestMessage)
    /// Things can have state / properties like battery level, temperature etc. Use this message
    /// to communicate changes to the backend .
    case propertyUpdate(ONPropertyUpdateMessage)
    /// Response to a ping.
    case pong(ONPongMessage)
    /// Each adapter should report the health state of all actions.
    /// The backend will not attempt to execute actions reported broken.
    case healthUpdate(ONHealthMessage)
    /// The result of an ActionRequestMessage.
    case actionResponse(ONActionResponseMessage)

  #if !swift(>=4.1)
    static func ==(lhs: ONMessageFromAdapter.OneOf_Message, rhs: ONMessageFromAdapter.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.receipt(let l), .receipt(let r)): return l == r
      case (.manifest(let l), .manifest(let r)): return l == r
      case (.propertyUpdate(let l), .propertyUpdate(let r)): return l == r
      case (.pong(let l), .pong(let r)): return l == r
      case (.healthUpdate(let l), .healthUpdate(let r)): return l == r
      case (.actionResponse(let l), .actionResponse(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The server can decide when it want to ping a client.
/// Each adapter MUST respond to every ping message with a corresponding PongMessage. 
struct ONPingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used by the adapter to respond to a PingMessage.
/// Make sure to set the replyToMessageId property to the message id of the ping message. 
struct ONPongMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional, short and human readable status message 
  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used to acknowledge or not acknowledge handling of a message.
/// Can be used to increase resilience by re-transmitting important messages. 
struct ONReceiptMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message was either accepted or rejected.
  var result: ONReceiptMessage.Result = .ack

  /// An optional status message for debugging.
  /// When rejecting a message it is nice to add a human readable explanation
  /// to simplify debugging.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Tells you if the message was accepted or rejected
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Message accepted / acknowledged
    case ack // = 0

    /// Message rejected. See message field for more information.
    case nak // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .ack
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ack
      case 1: self = .nak
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .ack: return 0
      case .nak: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ONReceiptMessage.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ONReceiptMessage.Result] = [
    .ack,
    .nak,
  ]
}

#endif  // swift(>=4.2)

/// Contains a detailed description of things attached to this adapter and the
/// actions the adapter supports.
///
/// This is the first message the adapter is supposed to send after connecting. 
struct ONManifestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A patch message will update / replace a subset of things the backend already know.
  /// By setting patch = false the backend will replace everything it knows about the
  /// things attached to the adapter with the content of this message.
  ///
  /// Patch messages are probably most useful if you have a lot of things attached to
  /// your adapter.. 
  var patch: Bool = false

  /// An updated description of all the things attached to the adapter right now
  /// and the actions they can execute. 
  var things: [ONThingDescription] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Each thing attached to the adapter can have readable properties like temperature,
/// uptime, battery level etc. Use this message to send updated values to the backend. 
struct ONPropertyUpdateMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// New property values
  var property: [ONPropertyUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Adapters will often communicate with other devices and systems. These integrations
/// can break and the adapter should report this to the backend to enable early warning
/// to users of OslonÃ¸kkelen.
///
/// Some important things to keep in mind:
/// 1. The backend will never try to execute an action reported broken.
/// 2. The backend will not execute an action before the adapter has reported it healthy
struct ONHealthMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Updated health status for one or more actions
  var healthStatus: [ONActionHealthStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to execute an action.
///
/// The description of the adapter sent with the manifest contains a list
/// required user and input parameters. These parameters is attached to this message.
struct ONActionRequestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies the thing
  var thingID: String = String()

  /// Identifies the action within the thing
  var actionID: String = String()

  /// Information about the end user requesting this action.
  /// Can be things like email, name etc.. Depends on the action
  /// description sent in the manifest.
  var actorParameters: Dictionary<String,String> = [:]

  /// Input parameters to the action itself. Example: Turn the light down to 50%
  /// Depends on the action description sent in the manifest.
  var inputParameters: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The result of an action. All action requests must be answered with this message. 
struct ONActionResponseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status, was the action executed successfully?
  var result: ONActionResponseMessage.Result = .success

  /// Error code that can be mapped to a human readable message.
  var errorCode: String = String()

  /// Output parameters.
  /// Example: Access codes
  var parameter: Dictionary<String,String> = [:]

  /// An optional technical status message intended for debugging.
  /// It will never be presented to the end user requesting the action.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Executed successfully
    case success // = 0

    /// Some permanent error, retrying the action will probably not help
    case error // = 1

    /// Some temporary error, retrying might help.
    case hiccup // = 2

    /// Access denied
    case denied // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .success
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .error
      case 2: self = .hiccup
      case 3: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .success: return 0
      case .error: return 1
      case .hiccup: return 2
      case .denied: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ONActionResponseMessage.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ONActionResponseMessage.Result] = [
    .success,
    .error,
    .hiccup,
    .denied,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "oslonokkelen.messages"

extension ONMessageFromServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageFromServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageId"),
    2: .same(proto: "replyToMessageId"),
    3: .same(proto: "receipt"),
    4: .same(proto: "ping"),
    5: .same(proto: "actionRequest"),
  ]

  fileprivate class _StorageClass {
    var _messageID: String = String()
    var _replyToMessageID: String = String()
    var _message: ONMessageFromServer.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _messageID = source._messageID
      _replyToMessageID = source._replyToMessageID
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._messageID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._replyToMessageID)
        case 3:
          var v: ONReceiptMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .receipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .receipt(v)}
        case 4:
          var v: ONPingMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .ping(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .ping(v)}
        case 5:
          var v: ONActionRequestMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .actionRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .actionRequest(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._messageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageID, fieldNumber: 1)
      }
      if !_storage._replyToMessageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._replyToMessageID, fieldNumber: 2)
      }
      switch _storage._message {
      case .receipt(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .ping(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .actionRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONMessageFromServer, rhs: ONMessageFromServer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._replyToMessageID != rhs_storage._replyToMessageID {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONMessageFromAdapter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageFromAdapter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageId"),
    2: .same(proto: "replyToMessageId"),
    5: .same(proto: "receipt"),
    6: .same(proto: "manifest"),
    7: .same(proto: "propertyUpdate"),
    8: .same(proto: "pong"),
    9: .same(proto: "healthUpdate"),
    10: .same(proto: "actionResponse"),
  ]

  fileprivate class _StorageClass {
    var _messageID: String = String()
    var _replyToMessageID: String = String()
    var _message: ONMessageFromAdapter.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _messageID = source._messageID
      _replyToMessageID = source._replyToMessageID
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._messageID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._replyToMessageID)
        case 5:
          var v: ONReceiptMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .receipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .receipt(v)}
        case 6:
          var v: ONManifestMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .manifest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .manifest(v)}
        case 7:
          var v: ONPropertyUpdateMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .propertyUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .propertyUpdate(v)}
        case 8:
          var v: ONPongMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .pong(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .pong(v)}
        case 9:
          var v: ONHealthMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .healthUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .healthUpdate(v)}
        case 10:
          var v: ONActionResponseMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .actionResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .actionResponse(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._messageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageID, fieldNumber: 1)
      }
      if !_storage._replyToMessageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._replyToMessageID, fieldNumber: 2)
      }
      switch _storage._message {
      case .receipt(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .manifest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .propertyUpdate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .pong(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .healthUpdate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .actionResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONMessageFromAdapter, rhs: ONMessageFromAdapter) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._replyToMessageID != rhs_storage._replyToMessageID {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONPingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONPingMessage, rhs: ONPingMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONPongMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PongMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeSingularStringField(value: &self.status)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONPongMessage, rhs: ONPongMessage) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONReceiptMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiptMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.result)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ack {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONReceiptMessage, rhs: ONReceiptMessage) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONReceiptMessage.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACK"),
    1: .same(proto: "NAK"),
  ]
}

extension ONManifestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManifestMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "patch"),
    2: .same(proto: "things"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.patch)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.things)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.patch != false {
      try visitor.visitSingularBoolField(value: self.patch, fieldNumber: 1)
    }
    if !self.things.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.things, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONManifestMessage, rhs: ONManifestMessage) -> Bool {
    if lhs.patch != rhs.patch {return false}
    if lhs.things != rhs.things {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONPropertyUpdateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropertyUpdateMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "property"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.property)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.property.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.property, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONPropertyUpdateMessage, rhs: ONPropertyUpdateMessage) -> Bool {
    if lhs.property != rhs.property {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONHealthMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "healthStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.healthStatus)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.healthStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.healthStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONHealthMessage, rhs: ONHealthMessage) -> Bool {
    if lhs.healthStatus != rhs.healthStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONActionRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionRequestMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "thingId"),
    2: .same(proto: "actionId"),
    3: .same(proto: "actorParameters"),
    4: .same(proto: "inputParameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.thingID)
      case 2: try decoder.decodeSingularStringField(value: &self.actionID)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.actorParameters)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.inputParameters)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.thingID.isEmpty {
      try visitor.visitSingularStringField(value: self.thingID, fieldNumber: 1)
    }
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 2)
    }
    if !self.actorParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.actorParameters, fieldNumber: 3)
    }
    if !self.inputParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.inputParameters, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONActionRequestMessage, rhs: ONActionRequestMessage) -> Bool {
    if lhs.thingID != rhs.thingID {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.actorParameters != rhs.actorParameters {return false}
    if lhs.inputParameters != rhs.inputParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONActionResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionResponseMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "errorCode"),
    3: .same(proto: "parameter"),
    4: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.result)
      case 2: try decoder.decodeSingularStringField(value: &self.errorCode)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameter)
      case 4: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.errorCode.isEmpty {
      try visitor.visitSingularStringField(value: self.errorCode, fieldNumber: 2)
    }
    if !self.parameter.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameter, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ONActionResponseMessage, rhs: ONActionResponseMessage) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.parameter != rhs.parameter {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ONActionResponseMessage.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "HICCUP"),
    3: .same(proto: "DENIED"),
  ]
}
